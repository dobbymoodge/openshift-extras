#!/usr/bin/env ruby

#####################################################################
# bootstrap our devops/onprem builder

$: << File.expand_path(File.dirname(__FILE__))
require 'dev_tools_constants'

DEVTOOLS_REPO = File.join('lib', '..', '..', '..', "#{DEV_TOOLS_REPO}")

require 'rubygems'
require 'thor'
require 'fileutils'
require File.join(DEVTOOLS_REPO, 'build', 'lib', 'openshift')
require 'pp'
require 'yaml'
require File.join(DEVTOOLS_REPO, 'build', 'builder')

include FileUtils

######################################################################
#
# Define the options available for the onprem builder

module DevOps
  class BuilderPlugin < OpenShift::Builder
    include OpenShift::BuilderHelper
    
    desc "install_required_packages", "Install the packages required, as specified in the spec files"
    method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
    def install_required_packages
      options.verbose? ? @@log.level = Logger::DEBUG : @@log.level = Logger::ERROR
      packages = get_required_packages
      unless run("su -c \"yum install -y --skip-broken --exclude=\\\"ruby-qpid-* qpid-* ghostscript-* java-1.6.0-openjdk-*\\\" #{packages} 2>&1\"")
        exit 1
      end
    end
    

    ######################################################################
    #
    # Supporting methods go here

    no_tasks do

      def download_artifacts(hostname)
        puts "Downloading logs and screenshots..."
        `rm -rf rhc/log; mkdir -p rhc/log/; pushd rhc/log > /dev/null; mkdir -p broker mcollective system screenshots selenium jbossas broker-profiler coverage; popd > /dev/null`
        scp_from(hostname, "/tmp/rhc/*", "rhc/log", 60, ssh_user)
        scp_from(hostname, "/var/www/openshift/broker/httpd/logs/access_log", "rhc/log/broker/access_log.log", 60, ssh_user)
        scp_from(hostname, "/var/www/openshift/broker/httpd/logs/error_log", "rhc/log/broker/error_log.log", 60, ssh_user)
        scp_from(hostname, "/var/www/openshift/broker/log/*", "rhc/log/broker", 60, ssh_user)
        scp_from(hostname, "/var/log/openshift/user_action.log", "rhc/log/broker/user_action.log", 60, ssh_user)
        scp_from(hostname, "/var/log/mcollective.*", "rhc/log/mcollective", 60, ssh_user)
        scp_from(hostname, "/var/log/httpd/access_log", "rhc/log/system/access_log.log", 60, ssh_user)
        scp_from(hostname, "/var/log/httpd/error_log", "rhc/log/system/error_log.log", 60, ssh_user)
        scp_from(hostname, "/var/log/yum.log", "rhc/log/system/yum.log", 60, ssh_user)
        scp_from(hostname, "/var/log/messages", "rhc/log/system/messages.log", 60, ssh_user)
        scp_from(hostname, "/var/log/secure", "rhc/log/system/secure.log", 60, ssh_user)
        scp_from(hostname, "/var/log/audit/audit.log", "rhc/log/system/audit.log", 60, ssh_user)
        scp_from(hostname, "/tmp/rhc/*_coverage", "rhc/log/coverage", 60, ssh_user)
        puts "Done"
      end
      
      # launch also calls this to perform some kind of validation of instance state
      def validate_instance(hostname, num_tries=2)
        # here we will check that it has access to the yum repos
        puts "Validating instance..."

        validation_output = ssh(hostname, 'yum info openshift-origin-broker --cacheonly', 30)
        if validation_output =~ /Name\s*:\s*openshift-origin-broker/
          puts "Instance is valid."
        else
          puts "ERROR - instance is not valid"
          puts "Node Acceptance Output:"
          puts validation_output
          exit 1
        end
      end
      
      def restart_services()
        run("service mcollective restart; service rhc-broker restart; service rhc-site restart", :verbose => options.verbose?)
      end
      
      def enterprise_repo_version(repo_name)
        repo_version = repo_name
        if repo_name =~ /enterprise-(\d.\d)/
          repo_version = $1
        end
        repo_version
      end
      
      def sync_impl(name, options)

        hostname = get_host_by_name_or_tag(name, options)

        # get the necessary repos cloned out to the instance
        clone_commands, working_dirs = sync_available_sibling_repos(hostname)
        update_remote_tests(hostname)

        if !options.skip_build?
          puts "Performing remote install...."
          output, exit_code = ssh(hostname, %{
##################
# Start shell code

set -e
#{options.clean_metadata? ? 'yum clean metadata' : ''}
rm -rf #{working_dirs}

#{clone_commands}

pushd #{DEV_TOOLS_EXT_REPO} > /dev/null
  build/devenv update#{options.verbose? ? ' --verbose' : ''} #{options.clean_metadata? ? ' --include_stale' : ''} 2>&1
popd > /dev/null

rm -rf #{working_dirs}
#{options.clean_metadata? ? "yum update -y rhc* *openshift* 2>&1;" : ''}

# End shell code
################
}, 900, true)

          if exit_code != 0
            puts "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
            puts "Build failed!  Exiting."
            puts output
            puts "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
            exit 1
          end
          puts "Done"
        end
      end
      
      def build_impl(name, build_num, image, conn, options)
        puts "Launching instance of AMI: #{image.id} - #{image.name}"
        instance = launch_instance(image, name + '_' + build_num)
        hostname = instance.dns_name

        puts "Building on: #{hostname}"

        begin
          manifest = nil
          begin
            if options.install_required_packages?
              puts "Updating all packages on the system..."
              output = ssh(hostname, "yum clean metadata; yum update -y 2>&1", 1800)
              puts "Done"
              print_highlighted_output('Update Output', output)
            
              output, exit_code = ssh(hostname, "yum -y install openssh-clients", 240, true)
              print_highlighted_output('Install OpenSSH Clients Output', output)
              exit 1 unless exit_code == 0
            end

            if options.reboot?
              reboot(instance)
            end

            puts "Uploading update-ip-address.sh script..."
            script_path = File.expand_path(File.dirname(__FILE__) + "/../misc/update-ip-address.sh")
            scp_to(hostname, script_path, "~/")
            puts "Done"

            puts "Uploading devenv script..."
            script_path = File.expand_path(File.dirname(__FILE__) + "/../misc/devenv/setup-devenv-repos.sh")
            scp_to(hostname, script_path, "~/")
            puts "Done"

            if options.install_required_packages?
              puts "Uploading yum client certificates..."
              pem_path = File.expand_path(File.dirname(__FILE__) + "/../misc/client-cert.pem")
              scp_to(hostname, pem_path, "/var/lib/yum/")
              pem_path = File.expand_path(File.dirname(__FILE__) + "/../misc/client-key.pem")
              scp_to(hostname, pem_path, "/var/lib/yum/")
              scp_to(hostname, "misc/devenv/root/.ssh/*", "/root/.ssh/")
              ssh(hostname, "chmod 0600 /root/.ssh/id_rsa; chmod 0644 /root/.ssh/id_rsa.pub /root/.ssh/known_hosts;")
              puts "Done"
            end

            ssh(hostname, "/bin/bash ~/setup-devenv-repos.sh #{enterprise_repo_version(options.yum_repo)};")
            
            puts "Updating all packages on the system..."
            output = ssh(hostname, "yum clean metadata; yum update -y 2>&1", 1800)
            puts "Done"
            print_highlighted_output('Update Output', output)

            output = ''
            clone_commands = repo_clone_commands(hostname)
            cmd = "set -ex;"
            if options.install_from_source? || options.install_from_local_source?
              if options.install_from_source?
                puts "Performing clean install from source..."
              elsif options.install_from_local_source?
                puts "Performing clean install from local source..."
              end
              init_repos(hostname)
              sync_repos(hostname) if options.install_from_local_source?
              cmd += "#{clone_commands}\n"
              cmd += "mkdir -p /tmp/tito;"
              SIBLING_REPOS.each_key do |repo_name|
                cmd += "pushd /root/#{repo_name}; git checkout #{options.branch}; popd;"
              end if options.install_from_source?

              cmd += %{

pushd /root/#{DEV_TOOLS_EXT_REPO} > /dev/null
  echo "Building all specs on the server..."
  build/devenv find_and_build_specs 2>&1
popd > /dev/null

mkdir /root/devenv-local/

cat > /etc/yum.repos.d/local.repo <<EOF
[devenv-local]
name=devenv-local
baseurl=file:///root/devenv-local/
enabled=0
gpgcheck=0
priority=1
EOF

cp /tmp/tito/x86_64/*.rpm /root/devenv-local/
cp /tmp/tito/noarch/*.rpm /root/devenv-local/
createrepo /root/devenv-local/

#TODO
#yum -y install rhc-devenv --enablerepo=devenv-local 2>&1
pushd /root/devenv-local/
  yum install -y *.rpm 2>&1
popd

pushd /root/#{DEV_TOOLS_EXT_REPO} > /dev/null
  build/devenv write_sync_history 2>&1
popd > /dev/null

rm -rf /tmp/tito; mkdir -p /root/.source_build;
}
              SIBLING_REPOS.each_key do |repo_name|
                cmd += "rm -rf /root/#{repo_name}-bare; rm -rf /root/.source_build/#{repo_name}; mv /root/#{repo_name} /root/.source_build/#{repo_name};"
              end
            elsif options.install_required_packages?
              puts "Installing bootstrap packages..."

              output, exit_code = ssh(hostname, "yum -y install git tito ruby rubygems rubygem-thor rubygem-parseconfig rubygem-json rubygem-aws-sdk createrepo yum-priorities charlie", 600, true)
              print_highlighted_output('Install Bootstrap Packages Output', output)
              exit 1 unless exit_code == 0
              puts "Done"

              puts "Installing requires..."
              init_repos(hostname)
              cmd += %{

#{clone_commands}
              
# Enable RHUI JBoss repos for cartridge rebase on core EAP packages
yum -y install rh-amazon-rhui-client-jbeap6
              
# Enable RHUI JB EWS repos for Tomcat cartridge
yum -y install rh-amazon-rhui-client-jbews1

yum -y install java-1.6.0-openjdk.x86_64 java-1.6.0-openjdk-devel.x86_64
yum -y install java-1.7.0-openjdk.x86_64 java-1.7.0-openjdk-devel.x86_64

pushd #{DEV_TOOLS_EXT_REPO}
  build/devenv install_required_packages 2>&1
popd
}
              SIBLING_REPOS.each_key do |repo_name|
                cmd += "rm -rf /root/#{repo_name}; rm -rf /root/#{repo_name}-bare;"
              end
            else
              puts "Performing clean install with the latest code..."
              #TODO
              #cmd += "yum -y install rhc-devenv;"
            end
                  
            output, exit_code = ssh(hostname, cmd, 3600, true)

            print_highlighted_output('Install Output', output)
            puts "Done"

            exit exit_code unless exit_code == 0

            validate_instance(hostname, 4) unless options.install_required_packages?

            manifest = rpm_manifest(hostname)
          rescue SystemExit => e
            download_artifacts(hostname) if options.terminate? || options.official?
            raise
          end

          output = ssh(hostname, "yum list installed", 120)

          print_highlighted_output('Installed Packages', output)

          unless options.install_required_packages?
            puts "Uploading openshift-amz.sh script..."
            script_path = File.expand_path(File.dirname(__FILE__) + "/../amazon/openshift-amz.sh")
            scp_to(hostname, script_path, "~/")
            puts "Done"

            puts "Running openshift-amz.sh..."
            out, ret = ssh(hostname, "/bin/bash ~/openshift-amz.sh 2>&1", 60 * 30, true)
            print_highlighted_output('openshift-amz.sh Output', out)
            print_and_exit(ret, out) if ret != 0
            puts "Done"
            
            puts "Validating...."
            #TODO Temporary workaround
            out, ret = ssh(hostname, "service openshift-broker restart", 60 * 30, true, 10)
            print_and_exit(ret, out) if ret != 0
            #out, ret = ssh(hostname, "oo-accept-node; oo-accept-broker", 60 * 30, true, 10)
            #print_and_exit(ret, out) if ret != 0
            puts "Done"
          end

          image_id = nil
          if options.register?
            image = register_image(conn, instance, name + '_' + build_num, manifest)
            image_id = image.id
          end

          unless options.skip_verify? || options.install_required_packages?
            scp_remote_tests(hostname, options.branch)
            test_impl(name + '_' + build_num, hostname, instance, conn, options, image_id)
          end
        ensure
          terminate_instance(instance) if options.terminate?
        end
      end
      
      def update_cucumber_tests(hostname, repo_parent_dir="/root", user="root")
        ssh(hostname, "rm -f #{repo_parent_dir}/openshift-test/tests; ln -s #{repo_parent_dir}/openshift-test/controller/test/cucumber #{repo_parent_dir}/openshift-test/tests ;", 60, false, 2, user)
      end
      
      def setup_verifier(hostname, branch)
        print "Initializing git repo for syncing..."
        init_repos(hostname)
        puts "Done"
        update_remote_tests(hostname, branch)
      end
      
      def test_impl(tag, hostname, instance, conn, options, image_id=nil)
        begin
          
          validate_instance(hostname, 4)
  
          #disable_charlie(hostname) if options.disable_charlie?
          
          mcollective_logs(hostname) if options.mcollective_logs?
  
          #idle_all_gears(hostname) unless options.official?
          
          reset_test_dir(hostname)
  
          #broker_profiler(hostname) if options.profile_broker?
  
          test_queues = [[], [], [], []]
            
          extended_tests = nil
          if options.include_extended
            extended_tests = []
            extended_tests = options.include_extended.split(",").map do |extended_test|
              extended_test.strip
            end
          end
  
          if options.include_extended
            extended_tests.each do |extended_test|
              case extended_test
              when 'broker'
                # The following tests need env.rb fixed.
                #test_queues[0] << ["REST API Group 1", "su -c \"cucumber #{CUCUMBER_OPTIONS} -t @broker_api1 openshift-test/tests\"", {:retry_individually => true}]
                #test_queues[1] << ["REST API Group 2", "su -c \"cucumber #{CUCUMBER_OPTIONS} -t @broker_api2 openshift-test/tests\"", {:retry_individually => true}]
                #test_queues[2] << ["REST API Group 3", "su -c \"cucumber #{CUCUMBER_OPTIONS} -t @broker_api3 openshift-test/tests\"", {:retry_individually => true}]
                #test_queues[3] << ["REST API Group 4", "su -c \"cucumber #{CUCUMBER_OPTIONS} -t @broker_api4 openshift-test/tests\"", {:retry_individually => true}]
                
                # The broker_key initializer in controller needs to be fixed before the test below can pass
                # The following test needs https://github.com/openshift/origin-server/commit/013b9698d406cf3a3d36594992612c5dbaca201d
                #test_queues[3] << ["OpenShift Origin Broker Unit Ext 1", "cd openshift-test/broker; bundle exec rake test:oo_unit_ext1", {:retry_individually => true}]
              when 'runtime'
                # The following tests need env.rb fixed.
                #test_queues[0] << ["Extended Runtime Group 1", "su -c \"cucumber #{CUCUMBER_OPTIONS} -t @runtime_extended1 openshift-test/tests\""]
                #test_queues[1] << ["Extended Runtime Group 2", "su -c \"cucumber #{CUCUMBER_OPTIONS} -t @runtime_extended2 openshift-test/tests\""]
                #test_queues[2] << ["Extended Runtime Group 3", "su -c \"cucumber #{CUCUMBER_OPTIONS} -t @runtime_extended3 openshift-test/tests\""]
              when 'site'
                puts "Warning: Site tests are currently not supported"
              when 'rhc'
                # The following tests need env.rb fixed.
                #test_queues[0] << ["RHC Extended", "su -c \"cucumber #{CUCUMBER_OPTIONS} -t @rhc_extended openshift-test/tests\"", {:retry_individually => true}]
                base_str = "QUIET=1 RHC_SERVER=localhost cucumber #{CUCUMBER_OPTIONS} openshift-test/features"
                tags = [
                  [ :client, :domain, :sshkey ],
                  [ :application ],
                  [ :single_cartridge ],
                  [ :multiple_cartridge ]
                ]
                (0..3).each do |q|
                  tags[q].each do |tag|
                    #test_queues[q] << ["RHC Functional: #{tag}", "#{base_str} -t @#{tag} "]
                  end
                end

                # TODO: Tests need to run serially until they are totally isolated
                #  eg - some will destroy a domain or app that another is working on
                tags.flatten.each do |tag|
                  #test_queues[0] << ["RHC Functional: #{tag}", "#{base_str} -t @#{tag}", {:retry_individually => true}]
                end

              else
                puts "Not supported for extended: #{extended_test}"
                exit 1
              end
            end
          elsif options.include_coverage?
            test_queues[0] << ["OpenShift Origin Node Unit Coverage", "cd openshift-test/node; rake rcov; cp -a coverage /tmp/rhc/openshift_node_coverage"]
            # The following test needs https://github.com/openshift/origin-server/commit/013b9698d406cf3a3d36594992612c5dbaca201d
            #test_queues[1] << ["OpenShift Origin Broker Unit and Functional Coverage", "cd openshift-test/broker; rake rcov; cp -a test/coverage /tmp/rhc/openshift_broker_coverage"]
          elsif options.include_cucumber
            timeout = @@SSH_TIMEOUT
            timeout = @@SSH_TIMEOUT_OVERRIDES[options.include_cucumber] if not @@SSH_TIMEOUT_OVERRIDES[options.include_cucumber].nil?
            # The cucumber tests need env.rb fixed.
            test_queues[0] << [options.include_cucumber, "cucumber #{CUCUMBER_OPTIONS} -t @#{options.include_cucumber} openshift-test/tests", {:timeout => timeout}]
          elsif options.include_web?
            puts "Warning: Tests for the website are currently not supported"
          else
  
            unless options.exclude_broker?
              test_queues[0] << ["OpenShift Origin Broker Functional", "cd openshift-test/broker; su -c \"bundle exec rake test:functionals\""]
              test_queues[1] << ["OpenShift Origin Broker Integration", "cd openshift-test/broker; su -c \"bundle exec rake test:integration\""]
              test_queues[1] << ["OpenShift Origin Broker Unit 1", "cd openshift-test/broker; su -c \"bundle exec rake test:oo_unit1\""]
              # The following test needs https://github.com/openshift/origin-server/commit/013b9698d406cf3a3d36594992612c5dbaca201d
              #test_queues[1] << ["OpenShift Origin Broker Unit 2", "cd openshift-test/broker; su -c \"bundle exec rake test:oo_unit2\""]
              # The following test needs env.rb fixed.
              #test_queues[2] << ["Broker Cucumber", "su -c \"cucumber --strict -f html --out /tmp/rhc/broker_cucumber.html -f progress -t @broker -t ~@not-origin -t ~@not-enterprise openshift-test/tests\""]
            end

            unless options.exclude_runtime?
              test_queues[3] << ["Runtime Unit", "cd openshift-test/node; su -c \"rake unit_test\""]
              (1..4).each do |i|
                # The following tests need env.rb fixed.
                #test_queues[i-1] << ["Runtime Group #{i.to_s}", "su -c \"cucumber #{CUCUMBER_OPTIONS} -t @runtime#{i.to_s} openshift-test/tests\""]
              end
            end
  
            unless options.exclude_site?
            end

            unless options.exclude_rhc?
            end
          end
  
          threads = []
          failures = []
  
          retry_threshold = 0
          test_queues.each do |test_queue|
            titles = []
            cmds = []
            retry_individually = []
            timeouts = []
            test_queue.each do |test|
              titles << test[0]
              cmds << test[1]
              opts = test[2] || {}
              retry_individually << opts[:retry_individually] ? true : false
              timeouts << opts[:timeout] ? opts[:timeout] : @@SSH_TIMEOUT
              retry_threshold += 8
            end
            add_ssh_cmd_to_threads(hostname, threads, failures, titles, cmds, retry_individually, timeouts, ssh_user)
          end
  
          threads.each do |t|
            t[0].join
          end
  
          failures.uniq!
  
          begin
            if failures.length > 0 && failures.length <= retry_threshold 
              #idle_all_gears(hostname)
              retry_test_failures(hostname, failures, 2, timeout=@@SSH_TIMEOUT, ssh_user)
            elsif failures.length > retry_threshold
              exit 1
            end
  
            # These are special tests that cannot be written to work concurrently
            if options.include_extended
              extended_tests.each do |extended_test|
                case extended_test
                when 'broker'
                when 'runtime'
                  singleton_queue = ['Singletons', "su -c \"cucumber #{CUCUMBER_OPTIONS} -t @singleton openshift-test/tests\""]
                  # These tests need env.rb fixed.
                  #output, exit_code = run_ssh(hostname, singleton_queue[0], singleton_queue[1], timeout=@@SSH_TIMEOUT, ssh_user)
                  #retry_test_failures(hostname, [singleton_queue], 2, timeout=@@SSH_TIMEOUT, ssh_user) if 0 != exit_code
                when 'site'
                when 'rhc'
                else
                  puts "Not supported for extended: #{extended_test}"
                  exit 1
                end
              end
            end
  
            validate_instance(hostname, 4)
          end
  
          if options.official?
            image_id = image_id ? image_id : instance.image_id
            # Mark the image as verified
            image = conn.images[image_id]
            verify_image(image)
  
            puts "Sending QE ready email..."
            begin
              send_verified_email(image_id, image.name)
            rescue Exception => e
              puts "Failed sending email with message: #{e.message}"
            end
          end
  
          puts "Done"
  
        ensure
          download_artifacts(hostname)
          
          begin
            terminate_instance(instance) if options.terminate?
          rescue
            # suppress termination errors - they have been logged already
          end
        end
      end
      
      def update_facts_impl(hostname)
        #TODO
      end
      
      def post_launch_setup(hostname)
        puts "Updating IP addresses in configuration files..."
        out, ret = ssh(hostname, "/bin/bash ~/update-ip-address.sh", 60, true)
        puts "Done"

        if ret != 0
          puts "Exiting with error code #{ret}"
          puts "Output: #{out}"
          exit ret
        end
      end
      
      def rpm_manifest(hostname, sshuser="root")
        print "Retrieving RPM manifest.."
        manifest = ssh(hostname, 'rpm -qa | grep -E "(openshift)" | grep -v cartridge', 60, false, 1, sshuser)
        manifest = manifest.split("\n").sort.join(" / ")
        # Trim down the output to 255 characters
        manifest.gsub!(/rubygem-([a-z])/, '\1')
        manifest.gsub!('openshift-origin-', '')
        manifest.gsub!('mcollective-', 'mco-')
        manifest.gsub!('.noarch', '')
        manifest.gsub!(/\.git\.[a-z0-9\.]+/, '')
        manifest = manifest[0..254]
        puts "Done"
        return manifest
      end

    end # no_tasks end
  end # class end
end # module end

DevOps::BuilderPlugin.start
