#!/usr/bin/env oo-ruby

def migrate(type)
  puts "Starting #{type} migrations."
  migrations = self.class.constants.grep(/Migrate_/).
                sort.
                map {|m| self.class.send(:const_get, m)}.
                select {|m| m::VERSIONS[type]}
  migrations.each do |m|
    puts "Running migration #{m::name}..."
    m::migrate(type)
    puts "Migration #{m::name} finished."
  end
  puts '', 'Migrations complete.'
end

###############################################################################
# The 2.0.37 migration code is taken from li repo, stage branch (will be 
# stage-2.0.37),
# rhc-broker/script/rhc-admin-migrate-datastore;
#
# * Wrapped the script in a module.

module Migrate_2_0_37
  VERSIONS = {
    :compatible => false,                                                                                      
    :"non-compatible" => true,                                                                                 
    :prerelease => false,                                                                                      
    :postrelease => false,                                                                                     
    :run_parallel => [:"non-compatible"]
  }

  def self.migrate(type)
    case type
    when :prerelease
    when :postrelease
    when :"non-compatible"
      flatten_gears
    when :compatible
    end
  end

  def self.flatten_gears
    puts "Running parallel migration : #{$parallel_index} of #{$num_processes}.."
    if $parallel_index.nil? or ($parallel_index == 0)
      db["applications"].drop_index("group_instances.gears.uuid_1") rescue nil 
    end
    filter = {}
    selection = {:fields => ["group_instances", "gears"], :timeout => false, :read => :primary}
    OpenShift::DataStore.find(:applications, filter, selection) do |app|
      begin
        next if app["_id"].to_s.sum.modulo($num_processes)!=$parallel_index
        next if app["gears"].is_a?(Array) and app["gears"].length>0
        new_gears = []
        updates = { "$set" => {}, "$unset" => {} }
        gi_index = -1
        app['group_instances'].each do |gi|
          gi_index += 1
          gi['gears'].each do |gear|
            new_gear = gear.deep_dup
            new_gear["group_instance_id"] = BSON::ObjectId(gi["_id"].to_s)
            new_gears << new_gear
          end if gi['gears'].present?
          updates["$unset"]["group_instances.#{gi_index}.gears"] = ""
        end if app['group_instances'].present?
        updates["$set"]["gears"] = new_gears
        db['applications'].update({"_id" => BSON::ObjectId(app["_id"].to_s) }, updates)
      rescue Exception => e
        puts "Failed to migrate app_id: #{app['_id'].to_s}, Error: #{e.message}"
        puts e.backtrace.inspect
      end
    end
    puts "Completed #{$parallel_index} of #{$num_processes} parallel tasks."
  end
  
end

###############################################################################
# The 2.0.39 migration code is taken from li repo, stage branch (will be 
# stage-2.0.39),
# rhc-broker/script/rhc-admin-migrate-datastore;
#
# * Wrapped the script in a module.

module Migrate_2_0_39
  VERSIONS = {
    :compatible => false,
    :"non-compatible" => true,
    :prerelease => false,
    :postrelease => false,
    :run_parallel => []
  }

  def self.migrate(type)
    case type
    when :prerelease
    when :postrelease
    when :"non-compatible"
      adjust_cartridge_versions
    when :compatible
    end
  end

  #
  # Update old cartridge names to be simpler
  #
  def self.adjust_cartridge_versions
    CARTRIDGE_CHANGES.each do |cart_change|
      puts "Updating cartridge #{cart_change['old_name']} to #{cart_change['new_name']}"

      print "Updating component instances for all applications...\t"
      update_component_instances(cart_change['old_name'], cart_change['new_name'], cart_change['new_version'])
      puts "Done."

      print "Updating group overrides for all applications...\t"
      update_group_overrides(cart_change['old_name'], cart_change['new_name'])
      puts "Done."

      print "Updating port interfaces for all application gears...\t"
      update_port_interfaces(cart_change['old_name'], cart_change['new_name'])
      puts "Done."

      print "Updating cartridge version for premium cartridges in usage...\t"
      update_premium_cart_version(cart_change['old_name'], cart_change['new_name'])
      puts "Done."

      print "Verifying cartridge update for all applications...\t"
      missed_update_count = verify_migration(cart_change['old_name'], cart_change['new_name'], cart_change['old_version'])
      puts missed_update_count == 0 ? "Successful." : "Failed."
      puts ""
    end
  end


  def self.update_component_instances(old_cart_name, new_cart_name, new_cart_version)
    ci_index = 0
    ci_search_count = 1
    while ci_search_count > 0 do
      filter = {"component_instances.#{ci_index}.cartridge_name" => old_cart_name}
      update_query = {"$set" => {"component_instances.#{ci_index}.cartridge_name" => new_cart_name,
                                 "component_instances.#{ci_index}.component_name" => new_cart_name,
                                 "component_instances.#{ci_index}.version" => new_cart_version}}
      db["applications"].update(filter, update_query, { :multi => true })

      ci_index += 1
      ci_search_count = db["applications"].find({"component_instances.#{ci_index}" => {"$exists" => true}}).count
    end
  end

  def self.update_group_overrides(old_cart_name, new_cart_name)
    # Update all the cartridge names in group_overrides
    go_index = 0
    go_search_count = 1
    while go_search_count > 0 do
      component_index = 0
      component_search_count = 1
      while component_search_count > 0
        filter = {"group_overrides.#{go_index}.components.#{component_index}.cart" => old_cart_name}
        update_query = {"$set" => {"group_overrides.#{go_index}.components.#{component_index}.cart" => new_cart_name,
                                   "group_overrides.#{go_index}.components.#{component_index}.comp" => new_cart_name}}
        db["applications"].update(filter, update_query, { :multi => true })
        component_index += 1
        component_search_count = db["applications"].find({"group_overrides.#{go_index}.components.#{component_index}" => {"$exists" => true}}).count
      end
      go_index += 1
      go_search_count = db["applications"].find({"group_overrides.#{go_index}" => {"$exists" => true}}).count
    end
  end

  def self.update_port_interfaces(old_cart_name, new_cart_name)
    # Update all the cartridge names in gear's port_interfaces
    g_index = 0
    g_search_count = 1
    while g_search_count > 0 do
      pi_index = 0
      pi_search_count = 1
      while pi_search_count > 0
        filter = {"gears.#{g_index}.port_interfaces.#{pi_index}.cartridge_name" => old_cart_name}
        update_query = {"$set" => {"gears.#{g_index}.port_interfaces.#{pi_index}.cartridge_name" => new_cart_name}}
        db["applications"].update(filter, update_query, { :multi => true })
        pi_index += 1
        pi_search_count = db["applications"].find({"gears.#{g_index}.port_interfaces.#{pi_index}" => {"$exists" => true}}).count
      end
      g_index += 1
      g_search_count = db["applications"].find({"gears.#{g_index}" => {"$exists" => true}}).count
    end
  end

  def self.update_premium_cart_version(old_cart_name, new_cart_name)
    filter = {"cart_name" => old_cart_name}
    update_query = {"$set" => {"cart_name" => new_cart_name}}

    db["usage"].update(filter, update_query, { :multi => true })
    db["usage_records"].update(filter, update_query, { :multi => true })
  end

  def self.verify_migration(old_cart_name, new_cart_name, old_cart_version)
    missed_update_count = 0
    missed_update_count += db["applications"].find({"component_instances.cartridge_name" => old_cart_name}).count
    missed_update_count += db["applications"].find({"component_instances.component_name" => old_cart_name}).count
    missed_update_count += db["applications"].find({"group_overrides.components.cart" => old_cart_name}).count
    missed_update_count += db["applications"].find({"group_overrides.components.comp" => old_cart_name}).count
    missed_update_count += db["applications"].find({"gears.port_interfaces.cartridge_name" => old_cart_name}).count
    missed_update_count += db["applications"].find({"component_instances" => {"$elemMatch" => {"cartridge_name" => new_cart_name, "cartridge_vendor" => "redhat", "version" => old_cart_version}}}).count
    missed_update_count += db["usage"].find({"cart_name" => old_cart_name}).count
    missed_update_count += db["usage_records"].find({"cart_name" => old_cart_name}).count

    missed_update_count
  end
  
end

###############################################################################
# Migration core code
#

require 'getoptlong'

def db
  $db ||= OpenShift::DataStore.db(:primary)
end

def p_usage
  puts <<USAGE

Usage: #{$0}

  --compatible                         Run the backwards-compatible portion of the migration (can be run after the system is upgraded with the brokers running)
  --prerelease                         Run the pre-release portion of the migration (can be run at any time and is re-entrant)
  --non-compatible                     Run the non-backwards compatible portion of the migration (must be run with the brokers shut down)
  --postrelease                        Run the post-release portion of the migration (can be run with brokers online, but node migration should have completed successfully)
  --help                               Show usage info
USAGE
  exit 255
end

begin
  opts = GetoptLong.new(
    ["--compatible", "-c", GetoptLong::NO_ARGUMENT],
    ["--non-compatible", "-n", GetoptLong::NO_ARGUMENT],
    ["--prerelease", "-p", GetoptLong::NO_ARGUMENT],
    ["--postrelease", "-o", GetoptLong::NO_ARGUMENT],
    ["--verbose", "-V", GetoptLong::NO_ARGUMENT],
    ["--help", "-h", GetoptLong::NO_ARGUMENT]
  )
  opt = {}
  opts.each do |o, a|
    opt[o[2..-1]] = a.to_s
  end
rescue Exception => e
  p_usage
end

if opt['help']
  p_usage
end

unless opt['compatible'] || opt['non-compatible'] || opt['prerelease'] || opt['postrelease']
  puts "compatible or non-compatible or prerelease or postrelease is required!"
  p_usage
end

if [opt['compatible'],opt['non-compatible'],opt['prerelease'],opt['postrelease']].compact.count > 2
  puts "compatible, non-compatible, prerelease and postrelease are mutually exclusive."
  p_usage
end

type = ((opt['compatible'] and :compatible) or (opt['non-compatible'] and :non_compatible) or (opt['prerelease'] and :prerelease) or (opt['postrelease'] and :postrelease))

$:.unshift('/var/www/openshift/broker')
require 'config/environment'

migrate(type)

puts "Done!"
